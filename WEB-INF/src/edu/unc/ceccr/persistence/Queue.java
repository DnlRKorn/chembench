package edu.unc.ceccr.persistence;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.Vector;
import java.util.concurrent.ConcurrentLinkedQueue;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.EnumType;
import javax.persistence.Enumerated;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Table;
import javax.persistence.Transient;

import org.hibernate.HibernateException;
import org.hibernate.criterion.Expression;
import org.hibernate.Session;
import org.hibernate.Transaction;
import org.hibernate.criterion.Order;

import edu.unc.ceccr.global.Constants;
import edu.unc.ceccr.persistence.Queue.QueueTask.jobTypes;
import edu.unc.ceccr.taskObjects.CreateDatasetTask;
import edu.unc.ceccr.taskObjects.QsarPredictionTask;
import edu.unc.ceccr.taskObjects.QsarModelingTask;
import edu.unc.ceccr.taskObjects.WorkflowTask;
import edu.unc.ceccr.utilities.*;

public class Queue {
	
	@Entity()
	@Table(name = "cbench_task")
	public static class QueueTask {
		
		public enum State {	queued, started, finished, error, PermissionRequired, deleted };
		public enum jobTypes { modeling, prediction, dataset };
		private State state;
		private String message;
		private Date finish;
		private Date start;
		private Date submit;
		public WorkflowTask task;
		private String userName;
		public String jobName;
		public Long id = null;
		public jobTypes jobType;
		private String modelMethod;
		private String modelDescriptors;
		private String ACTFile;
		private String SDFile;
		private int numCompounds;
		private int numModels;
		private String hasBeenViewed;
		
		public QueueTask(WorkflowTask task, String userName)throws FileNotFoundException,IOException {
			
			this.setSubmit(new Date()); 
			this.task = task;
			this.setUserName(userName);
			
			if (task instanceof QsarModelingTask) 
			{
				QsarModelingTask t = (QsarModelingTask) task;
				this.jobName = t.getJobName();
				this.jobType = jobTypes.modeling;
				this.ACTFile = t.getActFileName();
				this.SDFile = t.getSdFileName();
				Utility.writeToDebug("compounds in job: " + numCompounds, userName, t.getJobName());
				Utility.writeToDebug("models in job: " + numModels, userName, t.getJobName());
				//if it's a big job, require an admin's approval before running it.
				if(this.numCompounds>Constants.MAXCOMPOUNDS||this.numModels>Constants.MAXMODELS)
				{
					//if the user's an admin, just let the job run - no permission required.
					if(! Utility.isAdmin(userName)){	
						this.setState(State.PermissionRequired);
						
						try{
							instance.saveTaskRecord(this);
						}catch(ClassNotFoundException e){Utility.writeToDebug(e);}
						catch(SQLException e){Utility.writeToDebug(e);}
						
						try {
							String HtmlBody="(This message is automatically generated by the C-Chembench system.  Please do not reply.) "
							+"<br/><br/><br/>The user<b> "+userName+" </b>has been submitted the job <b>"+jobName+"</b>."
							+"This job has "+numCompounds+" compounds and "+numModels+" models.<br/> This job has been suspended."
							+"<br/> <br/>To permit this job, please log on to C-Chembench : "+Constants.WEBADDRESS
							+"<br/><br/> Thank you,"
							+"<br/><br/><br/>"
							+ new Date();
							SendEmails.sendEmailToAdmins("Permission Request", HtmlBody);
							
						} catch (Exception e) {
							Utility.writeToDebug(e);
						}
					}
					else{
						this.setState(State.queued);
					}
				}
				else {
					this.setState(State.queued);
				}
				
			}else if(task instanceof QsarPredictionTask){
				QsarPredictionTask t = (QsarPredictionTask) task;
				this.setState(State.queued);
				this.jobName = t.getJobName();
				this.jobType = jobTypes.prediction;
			}
			else if(task instanceof CreateDatasetTask){
				CreateDatasetTask t = (CreateDatasetTask) task;
				this.setState(State.queued);
				this.jobName = t.getJobName();
				this.jobType = jobTypes.dataset;
			}
			
			saveTask();
		}

		public void saveTask(){
			//saves the task into the database (in cbench_task table)
			try{
			instance.saveTaskRecord(this);}
			catch(SQLException e){
				Utility.writeToDebug(e);
			}
			catch(ClassNotFoundException e){
				Utility.writeToDebug(e);
			}
		}
		
		@Column(name = "num_comp")
		public int getNumCompounds()
		{
			return numCompounds;
		}
		public void setNumCompounds(int num)
		{
			this.numCompounds=num;
		}
		@Column(name = "num_models")
		public int getNumModels()
		{
			return numModels;
		}
		public void setNumModels(int num)
		{
			this.numModels=num;
		}

		@Column(name="state")
		@Enumerated(value = EnumType.STRING)
		public State getState() {
			return state;
		}
		
		@Transient
		public String getStateDisplay() {
			return state.toString();
		}

		public void setState(State state) {
			if(this.state == QueueTask.State.deleted){
				return;
			}
			
			if(this.userName != null && this.jobName != null){
				Utility.writeToDebug("State changed from " + this.state + " to " + state.toString(), userName, jobName);
				this.state = state;
				saveTask();
			}
			else{
				this.state = state;
			}
		}
		
		@Id
		@GeneratedValue(strategy = GenerationType.AUTO)
		@Column(name = "task_id")
		public Long getId() {
			return id;
		}

		public void setId(Long id) {
			this.id = id;
		}
		

		public void setSubmit(Date submit) {
			this.submit = submit;
		}

		public Date getSubmit() {
			return submit;
		}

		public void setStart(Date start) {
			this.start = start;
		}

		public Date getStart() {
			return start;
		}

		public void setFinish(Date finish) {
			this.finish = finish;
		}

		public Date getFinish() {
			return finish;
		}
        @Column(name="username")
		public String getUserName() {
			return userName;
		}

		public void setUserName(String userName) {
			this.userName = userName;
		}

		@Column(name="jobname")
		public String getJobName() {
			return jobName;
		}

		public void setJobName(String jobName) {
			this.jobName = jobName;
		}

		@Column(name="message")
		public String getMessage() {
			return message;
		}
		public void setMessage(String message) {
			this.message = message;
			if(this.getState() != null){
				this.saveTask();
			}
		}
		
		@Column(name = "hasBeenViewed")
		public String getHasBeenViewed() {
			return hasBeenViewed;
		}
		public void setHasBeenViewed(String hasBeenViewed) {
			this.hasBeenViewed = hasBeenViewed;
		}

		
		public QueueTask() { super(); }

		@Enumerated(EnumType.STRING)
		@Column(name = "job_type")
		public jobTypes getJobType() {
			return jobType;
		}

		public void setJobType(jobTypes jobType) {
			this.jobType = jobType;
		}
		
		@Transient
		public String getJobTypeString() {
			return jobType.toString();
		}

		@Column(name = "ACTFileName")
		public String getACTFile() {
			return ACTFile;
		}

		public void setACTFile(String file) {
			ACTFile = file;
		}

		@Column(name = "model_descriptors")
		public String getModelDescriptors() {
			return modelDescriptors;
		}
		public void setModelDescriptors(String modelDescriptors) {
			this.modelDescriptors = modelDescriptors;
		}

		@Column(name = "model_method")
		public String getModelMethod() {
			return modelMethod;
		}
		public void setModelMethod(String modelMethod) {
			this.modelMethod = modelMethod;
		}

	
		@Column(name = "SDFileName")
		public String getSDFile() {
			return SDFile;
		}
		public void setSDFile(String file) {
			SDFile = file;
		}
		
		public void cleanFiles()
		{
			Utility.writeToMSDebug("Cleaning files from queue::"+Constants.CECCR_USER_BASE_PATH +this.getUserName()+"/"+this.getJobName());
			String BASE=Constants.CECCR_USER_BASE_PATH ;
			File file=new File(BASE+this.getUserName()+"/"+this.getJobName());
		    FileAndDirOperations.deleteDir(file);
		}

	}
	
	//////////////////////////////////////////////////////////////////////////////////////////////

	public static ConcurrentLinkedQueue<QueueTask> queue = new ConcurrentLinkedQueue<QueueTask>();
	public static ConcurrentLinkedQueue<QueueTask> errorqueue = new ConcurrentLinkedQueue<QueueTask>();
	public static Vector<QueueTask> lsfQueue = new Vector<QueueTask>(); //actual queueing is done by LSF, not by us.
	
	public static Queue instance = new Queue();
	
	public static Queue getInstance() {	return instance;	}

	public QueueTask runningTask;
	
	private Queue() {
		super();
		try {
			loadTaskRecords();
		} catch (Exception e) {
			Utility.writeToDebug(e);
		}
		startRunning();
	}
	
	public void startRunning()
	{
	    exec=new Qthread();
		exec.start();
	}
	public  void interruptRunning()throws InterruptedException
	{
		//exec.done();
	}
	public volatile Qthread exec;
	
	public class Qthread extends Thread
	{
		private boolean threadDone = false;
		
		public void done() {
	        threadDone = true;
	    }
		
		public void run() 
		{
			while (!threadDone){
				
				//check if any jobs in the lsfQueue need to be started, or are finished.
				
				while (queue.isEmpty()) {
					try{
						//Utility.writeToDebug("empty queue.");
						sleep(500);
					} catch (InterruptedException e) {
						Utility.writeToDebug(e);
					}
				}
				
				try{
					//Utility.writeToDebug("empty queue.2");
					sleep(500);
				} catch (InterruptedException e) {
					Utility.writeToDebug(e);
				}
				//Utility.writeToDebug("non-empty queue.");
				
				QueueTask.State state=QueueTask.State.queued;

				QueueTask t = queue.poll();
				Utility.writeToDebug("Task found at top of queue.", t.userName, t.jobName);

				try{ 
					state=loadState(t);
				}catch(Exception e){
					Utility.writeToDebug(e);
				}
				
				if(state==QueueTask.State.deleted)
			    {
			    	deleteTask(t);
			    }
			    else if(state.equals(QueueTask.State.PermissionRequired)){
					if(t.task != null){
						queue.add(t);
					}
					else{
						queue.remove(t);
					}
					
					try{sleep(100);}		
					catch (InterruptedException e) 	{	Utility.writeToDebug(e);	}
				
				}else{
					try {
						t.setStart(new Date());
						t.setState(QueueTask.State.started);
						runningTask = t;
						saveTaskRecord(runningTask);
						Utility.writeToDebug("Starting task.", t.userName, t.jobName);
	
						if(t.task != null){
							t.task.execute();
							t.task.cleanUp();
						}
						else{
							//t.setMessage("server reset");
							throw new Exception("Job does not contain a workflowTask. Cannot execute.");
						}
	
						Utility.writeToDebug("Task finished.", t.userName, t.jobName);
						t.setFinish(new Date());
						t.task.save();
						t.setState(QueueTask.State.finished);		
						

						runningTask = null;
						
						for(QueueTask ta : queue){
							if(ta.jobName.equals(t.jobName) && ta.userName.equals(t.userName)){
								queue.remove(ta);
							}
						}						
					} catch (Exception e) {
						Utility.writeToDebug(e);
						t.setState(QueueTask.State.error);
						errorqueue.add(t);
						queue.remove(t);
					}
				}
				
			}
		}
	}
	
	public void addJob(WorkflowTask job, String userName, String jobName, int numCompounds, int numModels) throws FileNotFoundException,IOException,SQLException,ClassNotFoundException{
		QueueTask qt = new QueueTask(job, userName);
		qt.setNumCompounds(numCompounds);
		qt.setNumModels(numModels);
		qt.setSubmit(new Date());
		saveTaskRecord(qt);
		queue.add(qt);
		Utility.writeToDebug("Adding Task to Chembench queue ", userName, jobName);
	}
	
	public void addJobForLsf(WorkflowTask job, String userName, String jobName, int numCompounds, int numModels) throws FileNotFoundException,IOException,SQLException,ClassNotFoundException{
		QueueTask qt = new QueueTask(job, userName);
		qt.setNumCompounds(numCompounds);
		qt.setNumModels(numModels);
		qt.setSubmit(new Date());
		saveTaskRecord(qt);
		lsfQueue.add(qt);
		Utility.writeToDebug("Adding Task to LSF Queue ", userName, jobName);
	}

	protected QueueTask.State loadState(QueueTask task) throws HibernateException, ClassNotFoundException, SQLException 
	{
		Utility.writeToDebug("loadState");
		QueueTask t=null;
		Session s = HibernateUtil.getSession();
		Transaction tx = null;
		try {
			tx = s.beginTransaction();
			t=(QueueTask)s.createCriteria(QueueTask.class).add(Expression.eq("jobName", task.jobName))
			    .add(Expression.eq("userName",task.userName)).uniqueResult();
			tx.commit();
		} catch (RuntimeException e) {
			if (tx != null)
				tx.rollback();
			Utility.writeToDebug(e);
		} finally {
			s.close();
		}
		
		return t.getState();
	}

	protected void saveTaskRecord(QueueTask t) throws HibernateException, ClassNotFoundException, SQLException {
		Utility.writeToDebug("saveTaskRecord");
		Session s = HibernateUtil.getSession();
		Transaction tx = null;
		try {
			tx = s.beginTransaction();
			s.saveOrUpdate(t);			
			tx.commit();
		} catch (RuntimeException e) {
			if (tx != null)
				tx.rollback();
			Utility.writeToDebug(e);
		} finally {
			s.close();
		}
	}
	
	protected void deleteTaskRecord(QueueTask t) throws HibernateException,
			ClassNotFoundException, SQLException {
		Utility.writeToDebug("DeleteTaskRecord: " + t.id);
		
		try{
		for (Iterator<QueueTask> i = queue.iterator(); i.hasNext( ); ) {
			QueueTask task = i.next( );
			if(t.id.compareTo(task.id) == 0)
			{
				Utility.writeToDebug("removing " + t.jobName);
				if(queue.remove(task)){
					Utility.writeToDebug("removed task.");
				}
				else{
					Utility.writeToDebug("task not removed.");
				}
			}
		}
		
		for (Iterator<QueueTask> i = errorqueue.iterator(); i.hasNext( ); ) {
			QueueTask task = i.next( );
			if(t.id.compareTo(task.id) == 0)
			{
				Utility.writeToDebug("removing " + t.jobName);
				if(errorqueue.remove(task)){
					Utility.writeToDebug("removed task.");
				}
				else{
					Utility.writeToDebug("task not removed.");
				}
			}
		}
		}
		catch(Exception ex){
			Utility.writeToDebug(ex);
		}
		
		Utility.writeToDebug("deleteTaskRecord");
		Session s = HibernateUtil.getSession();
		Transaction tx = null;
		try {
			tx = s.beginTransaction();
			s.delete(t);
			
			if(t.jobType.equals(jobTypes.prediction)){
				//s.delete(PopulateDataObjects.getPredictionTaskById(t.id));
				Utility.writeToMSDebug("DELETE PREDICTION TASK::"+t.id );
			}
			if(t.jobType.equals(jobTypes.modeling)){
				//s.delete(PopulateDataObjects.getModelingTaskById(t.id));
			}
			if(t.jobType.equals(jobTypes.dataset)){
				//s.delete(PopulateDataObjects.getVisualizationTaskById(t.id));				
			}

			tx.commit();
		} catch (RuntimeException e) {
			if (tx != null)
				tx.rollback();
			Utility.writeToDebug(e);
		} finally {
			s.close();
		}
	}

	@SuppressWarnings("unchecked")
	public void loadTaskRecords() throws HibernateException,
			ClassNotFoundException, SQLException {
		Utility.writeToDebug("loadTaskRecords");
		Session s = HibernateUtil.getSession();
		Transaction tx = null;
		List<QueueTask> ls = new LinkedList<QueueTask>();
		try {
			tx = s.beginTransaction();
			ls.addAll(s.createCriteria(QueueTask.class).addOrder(
					Order.asc("submit")).list());
			tx.commit();
		} catch (RuntimeException e) {
			if (tx != null)
				tx.rollback();
			Utility.writeToDebug(e);
		} finally {
			s.close();
		}

		Utility.writeToDebug("Loading tasks from database.");
		//Utility.writeToDebug("tasks in queue:");
		for (Iterator<QueueTask> i = ls.iterator( ); i.hasNext( ); ) {

			QueueTask t = i.next( );
			//Utility.writeToDebug("task: " + t.jobName + " status: " + t.state);
			
			if(t.state==QueueTask.State.finished || t.state==QueueTask.State.error)
			{
				//Utility.writeToDebug("Adding job " + t.jobName + " to finished.");
				errorqueue.add(t);
			}
			else{
				//Utility.writeToDebug("Adding job " + t.jobName + " to queue.");
				queue.add(t);
			}
		}
	}

	
	@SuppressWarnings("unchecked")
	public List<QueueTask> getQueuedTasks()throws SQLException,ClassNotFoundException {
		List<QueueTask> ls = new LinkedList<QueueTask>();
		
		if(runningTask!=null){ls.add(runningTask);}
		Utility.writeToDebug("getQueuedTasks");
		Session s = HibernateUtil.getSession();
		Transaction tx = null;
		try {
			tx = s.beginTransaction();
			ls.addAll(s.createCriteria(QueueTask.class).addOrder(Order.asc("submit")).add(Expression.eq("state",QueueTask.State.PermissionRequired)).list());
					    
			tx.commit();
		} catch (RuntimeException e) {
			if (tx != null)
				tx.rollback();
			Utility.writeToDebug(e);
		} finally {
			s.close();
		}
		
		return ls;
	}
	
	@SuppressWarnings("unchecked")
	public List<QueueTask> totalTasksInQ() throws HibernateException,ClassNotFoundException, SQLException {
		List<QueueTask> ls = new LinkedList<QueueTask>();
		Utility.writeToDebug("totalTasksInQ");
		Session s = HibernateUtil.getSession();
		Transaction tx = null;
		try {
			tx = s.beginTransaction();
			ls.addAll(s.createCriteria(QueueTask.class).addOrder(Order.asc("submit"))
					.add(Expression.ne("state",QueueTask.State.finished)).add(Expression.ne("state",QueueTask.State.error)).list());
			tx.commit();
		} catch (RuntimeException e) {
			if (tx != null)
				tx.rollback();
			Utility.writeToDebug(e);
		} finally {
			s.close();
		}
		
		return ls;
	}
	
	public List<QueueTask> getUserTasks(String userName) {
		List<QueueTask> ls = new LinkedList<QueueTask>();
		errorqueue.clear();
		try{
			loadTaskRecords();
		}catch(Exception e){
			Utility.writeToDebug(e);
		}
		for (QueueTask t : errorqueue) {
			if (t.getUserName().equals(userName)) {
				if(t.getState().equals(QueueTask.State.finished) || t.getState().equals(QueueTask.State.error))
				{ls.add(t);}
			}
		}
		for (QueueTask t : queue) {
			if (t.getUserName().equals(userName)) {
				if(t.getState().equals(QueueTask.State.finished) || t.getState().equals(QueueTask.State.error))
				{ls.add(t);}
			}
		}
		return ls;

	}

	public void deleteTask(WorkflowTask task) {
		QueueTask del = null;
		Utility.writeToDebug("Looking for task in 'finished' queue.");
		for (QueueTask t : errorqueue) {
			if (t.task == task)
				del = t;
		}
		if (del == null) {
			Utility.writeToDebug("Not found in 'finished' queue. Looking in queue.");
			//what if the job was not in "finished"? We still need to remove it!
			for (QueueTask t : queue) {
				if (t.task == task){
						del = t;
				}
			}
		}
		
		if (del == null && runningTask.task == task) {
			del = runningTask;
			try {
				deleteTaskRecord(del);
			} catch (Exception ex) {
				Utility.writeToDebug(ex);
			}
			runningTask = null;
		}
		else if (del != null) {
			errorqueue.remove(del);
			try {
				deleteTaskRecord(del);
			} catch (HibernateException e) {
				Utility.writeToDebug(e);
			} catch (ClassNotFoundException e) {
				Utility.writeToDebug(e);
			} catch (SQLException e) {
				Utility.writeToDebug(e);
			}
		}
	}
	
	public void deleteTask(QueueTask task) {
		if (task != null) {
			if(task == runningTask){
				runningTask = null;
			}
			errorqueue.remove(task);
			queue.remove(task);
			Utility.writeToDebug("DeleteTask: " + task.id);
			try {
				if(task.getState() == QueueTask.State.PermissionRequired){
					task.setState(QueueTask.State.deleted);
				}
				else{
					deleteTaskRecord(task);
				}
			} catch (Exception ex) {
				Utility.writeToDebug(ex);
			} 
		}
	}
}
